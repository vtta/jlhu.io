<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible" />
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />

  
    
  

  
    
  

  
    
  

  

  
    
  

  <title>Junliang Hu 胡俊良</title>

  
    <meta name="title" content="Junliang Hu 胡俊良">
    <meta name="author" content="Junliang Hu">
    <meta name="description" content="Junliang Hu&#x27;s homepage">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jlhu.io/2025-04/03-sosp25-motivation/">
    <meta property="og:site_name" content="Junliang Hu 胡俊良">
    <meta property="og:title" content="Junliang Hu 胡俊良">
    <meta property="og:description" content="Junliang Hu&#x27;s homepage">
    

    
    
      <meta property="twitter:card" content="summary_large_image">
      <meta property="twitter:url" content="https://jlhu.io/2025-04/03-sosp25-motivation/">
      <meta property="twitter:title" content="Junliang Hu 胡俊良">
      <meta property="twitter:description" content="Junliang Hu&#x27;s homepage">
      
    

    <link rel="canonical" href="https://jlhu.io/2025-04/03-sosp25-motivation/">
    
    <script type="application/ld+json">
      {
          "description": "Junliang Hu's homepage",
          "url": "https://jlhu.io/2025-04/03-sosp25-motivation/",
          "@type": "WebSite",
          "headline": "Junliang Hu 胡俊良",
          "name": "Junliang Hu 胡俊良",
          "author": { "@type": "Person", "name": "Junliang Hu" },
          "@context":"https://schema.org"
      }
    </script>
  

  

   
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            // • rendering keys, e.g.:
            throwOnError : false
          });
      });
  </script>
  

  
    <link rel="stylesheet" href="https://jlhu.io/style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons@latest/iconfont/tabler-icons.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  
</head>

<body theme="auto">
  <div class="w">
    <header>
      
        <nav>
          
            <a href="/" >~jlhu</a>
          
            <a href="/tags" >#tags</a>
          
        </nav>
      

      
  <p>
    <a href="..">..</a>/03-sosp25-motivation
  </p>
  <p class="post-meta">
    <time datetime=""></time>
  </p>
  <h1></h1>

    </header>

    <main class="page-content" aria-label="Content">
      
  

  <h2 id="motivation">Motivation</h2>
<ul>
<li>
<p>TLB flush</p>
<ul>
<li>Analysis of SOTA
<ul>
<li>why use H-TPP
<ul>
<li>No opensource </li>
</ul>
</li>
</ul>
</li>
<li>Demo by experiments 
<ul>
<li>Guest TPP vs Host TPP</li>
</ul>
</li>
<li>Explanation 
<ul>
<li>H-TPP: EPT -&gt; invept</li>
<li>HeteroVisor/HeteroOS/vTMM: despite tracking GPT
<ul>
<li>two kinds of flush instructions, full flush and gVA flush.
INVEPT &gt;&gt; INVVPID / INVLPG / INVPCID</li>
<li>GPT PTE cannot be reversed back to gVA</li>
<li>Hypervisor-based management requires full flush </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>EPT-friendly PEBS</p>
<ul>
<li>Feasibility</li>
</ul>
</li>
<li>
<p>Scalability issue of naive guests</p>
<ul>
<li>Delicated Polling </li>
</ul>
</li>
</ul>
<h4 id="version-1">version 1</h4>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>= Motivation
</span><span>
</span><span>// In this section, we identify three key challenges that current approaches face: TLB flush overhead, PEBS accessibility, and scalability concerns. These challenges inform our guest-delegated design principle.
</span><span>
</span><span>== TLB Flush Overhead &lt;motivation-overhead&gt;
</span><span>
</span><span>Access tracking in existing hypervisor-based tiered memory management solutions depends on TLB flush-intensive PTE.A bits for hotness information.
</span><span>To quantify this overhead, we compared TLB flush instruction counts between hypervisor-based and guest-based solutions.
</span><span>
</span><span>Due to the lack of available source code and omitted design details in existing hypervisor-based solutions @vee15heterovisor @socc16raminate @isca17heteroos @eurosys23vtmm, we converted the host-based TPP @asplos23tpp to a hypervisor-based solution (H-TPP) by integrating its PTE.A scanning backend with KVM&#39;s MMU notifier. 
</span><span>This allows it to observe guest accesses through PTE.A bits in EPT.
</span><span>For guest-based solutions, we evaluated a direct application of the host-based TPP in guests (G-TPP).
</span><span>
</span><span>For our evaluation, we limited the hypervisor-based system to 36 GB DRAM during boot, while for guest-based solutions, we started a VM with 36 GB DRAM.
</span><span>We used PMEM as the SMEM tier and ran a GUPS workload with a 144 GB total footprint using 36 threads, as shown in fig-motivation-tlb-flush.
</span><span>The results reveal that the hypervisor-based solution H-TPP generates 4.7× TLB flush instructions compared to G-TPP, resulting in 2.5× total execution time.
</span><span>
</span><span>The severe performance penalty stems from the necessity of destructive full invalidation of all EPT mappings.
</span><span>TLB flush instructions fall into two categories: full invalidation (`invept`) and single gVA invalidation (`invvpid`/`invpcid`/`invlpg`).
</span><span>Hypervisor-based solutions, which capture GPT entries through faulting @vee15heterovisor @isca17heteroos or scanning @eurosys23vtmm, can only access GPT and EPT entries containing gPA and hPA.
</span><span>Without gVA information, they must resort to full invalidation to ensure capturing future PTE.A/D bits.
</span><span>In contrast, guest-based solutions can follow the entire GPT walk process and extract the initial gVA, enabling the use of more efficient single-address invalidations.
</span><span>Furthermore, guest-based solutions can leverage EPT-friendly PEBS instead of TLB flush-intensive PTE.A/D bits.
</span><span>
</span><span>== EPT-Friendly PEBS
</span><span>
</span><span>Contrary to prior assumptions @eurosys23vtmm @osdi24memstrata, we find that PEBS sampling is now well-supported with strong isolation for guest states under virtualization @lkml22eptfriendlypebs.
</span><span>Cross-architecture support for PMU sampling also exists @lkml24riscvguestsampling, allowing PEBS-based hotness classification to extend to a wide range of cloud machines with simple modifications to the collected events.
</span><span>
</span><span>The primary concern regarding guest PEBS support has been the potential breach of isolation boundaries caused by sharing the sample buffer, potentially leaking sensitive information across VMs.
</span><span>Prior systems intuitively assumed that PEBS enabled in guests would generate samples and write to the host OS&#39;s PEBS buffer @eurosys23vtmm, leaking load/store addresses via generated samples.
</span><span>However, we found this is not the case.
</span><span>
</span><span>The PEBS sample buffer is part of the CPU debug control data structure and is managed via a debug control register.
</span><span>Hardware virtualization automatically switches to a guest-private PEBS buffer through the `vmcs.debugctl` field in the Virtual Machine Control Structure.
</span><span>Samples generated while executing different VMs are written directly to their private buffers, ensuring proper isolation.
</span><span>
</span><span>== Scalability Challenges
</span><span>
</span><span>With PEBS now available in guests, it might seem intuitive to apply existing PEBS-based designs directly within guest VMs.
</span><span>However, cloud environments often run numerous VMs concurrently on a single machine, which would compound management overhead if existing designs were directly repurposed.
</span><span>For instance, HeMem @sosp21hemem dedicates one CPU core to pulling samples from the PEBS buffer, which would waste one core per VM, a prohibitive overhead in multi-tenant environments.
</span><span>
</span><span>We conducted a scalability study of existing designs using both PTE.A/D-based (TPP) and PEBS-based (Memtis) approaches, as shown in @fig-motivation-scalability.
</span><span>We launched up to nine virtual machines on a 36-core system and ran 8.1 billion GUPS transactions with a 126 GiB working set divided evenly across all VMs while preserving the access distribution.
</span><span>
</span><span>The results demonstrate that naively using TPP in guests could waste more than 3.5 CPU cores in a 36-core system, while even the optimized PEBS design of Memtis still wastes approximately half a core.
</span><span>In cloud environments where CPU resources are rented to customers with the goal of maximizing utilization, such wastage would increase total cost of ownership (TCO), potentially negating the benefits of memory expansion through tiered memory.
</span><span>
</span><span>// These findings highlight the need for a fundamentally new approach to tiered memory management in virtualized environments—one that leverages the benefits of guest-side access tracking while addressing the scalability challenges of existing designs. This motivates our guest-delegated principle and the development of HyperFlex and HyperPlace, which we detail in the following sections.
</span></code></pre>
<h4 id="draft">Draft</h4>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>= Motivation
</span><span>
</span><span>== TLB flush
</span><span>Access tracking in existing hypervisor-based tiered memory management solutions, depends on TLB flush intensive PTE.A bits hotness information.
</span><span>We present a TLB flush instruction count measurement comparison between hypervisor-based and guest-based solutions.
</span><span>Because the lack of avaialble source code and ommitance of design details of existing hypervisor-based solutioins @vee15heterovisor @socc16raminate @isca17heteroos @eurosys23vtmm, we convert host-based TPP @asplos23tpp to a hypervisor-based soltion, named H-TPP, by plugging its PTE.A scanning backend with KVM&#39;s MMU notifier, allowing it to observe guest accesses through PTE.A bits in EPT.
</span><span>For guest-based solutions, we present results of directly applying existing host-based solution TPP in guests, named G-TPP, and our HyperTier design.
</span><span>
</span><span>For hypervisor-based, we limit usable DRAM of the evaluation machine to 36G during boot, for guest-based, we start a VM with 36G DRAM.
</span><span>We use PMEM as the SMEM tier.
</span><span>We run a GUPS workload with 144G total footprint with 36 threads and plot results in @fig-motivation-tlb-flush.
</span><span>The results show hypervisor-based solution H-TPP exhibits 4.7x total TLB flush instruction counts compared to G-TPP, taking 2.5x total execution time to finish.
</span><span>
</span><span>The culprint behind such severe performance penality is the necessity of destructive full invalidation to all EPT mappings.
</span><span>TLB flush instrictions can be catergorized into two kinds, full invalidation (`invept`) and single gVA invalidation (`invvpid/invpcid/invlpg`).
</span><span>Because hypervisor-based solutions, capturing GPT entries through faulting @vee15heterovisor @isca17heteroos and scanning @eurosys23vtmm, can only see GPT entries and EPT entries, which only contains gPA and hPA, they have to resorts to a full invalidation because the lack of gVA, to ensure the capture of futher PTE.A/D bits.
</span><span>However, guest-based solution is able to follow the entire process of GPT walk and extract the initial gVA, enabling the use of cheaper single invalidation.
</span><span>Furthermore, guest-based solutions is now able to leverage more efficient EPT-friendly PEBS instead of TLB flush intensive PTE.A/D bits.
</span><span>
</span><span>== EPT-friendly PEBS
</span><span>Contrary to prior assumptions @eurosys23vtmm @osdi24memstrata, we find that PMU sampling is now well-supported with strong isolation for guest states under virtualization @lkml22eptfriendlypebs.
</span><span>Even cross-architecture support for PMU sampling exists @lkml24riscvguestsampling, allowing extending PMU sampling based hotness classification to a wide arrange of machines in the cloud with simple changes on the collected events.
</span><span>
</span><span>The main concern for guest PEBS support is the _potential_ breach of isolation boundaries caused by sharing the sample buffer and leaking sensitive information across VMs.
</span><span>Prior systems intuitively assume that PEBS enabled in the guests will generate samples and write to the host OS&#39;s PEBS buffer @eurosys23vtmm, leaking load/store addresses via generated samples. 
</span><span>However, we found that this is not the case.
</span><span>The PEBS sample buffer is part of the CPU debug control data structure and is controlled via a debug control register.
</span><span>Hardware virtualization automatic switches to a guest-private PEBS buffer via `vmcs.debugctl` field in the Virtual Machine Control Structure’s.
</span><span>Samples generated in executing different VM will be written directly to its private buffer ensuring isolation.
</span><span>
</span><span>== Scalability
</span><span>With the avaialbity of PEBS in guests, its intuitive to apply prior PEBS-based designs directly in guests.
</span><span>However, a machine often have a large number of VMs running concurrently, a direct repurposing would mean compound management overhead.
</span><span>HeMem @sosp21hemem dedicate one core to pull samples from the PEBS buffer, wasting the total number of VMs worth of CPU cores just on access tracking.
</span><span>
</span><span>We present a scalability study of eixting both of PTE.A/D (TPP) and PEBS-based (Memtis) designs in @fig-motivation-scalability.
</span><span>We launch up to nine virtual machines on a 36 core machine and 8.1 billion GUPS transactions with a 126 GiB working set divided evenly across all virtual machines while preserving the access distribution.
</span><span>
</span><span>Results show that, naively using TPP as guests could waste more than three and a half CPU cores in a 36-core system, while optimized PEBS design like Memtis still waste half a core.
</span><span>Cloud environments rent CPU resources to customers and often aim for maximal resource utilization.
</span><span>Such wastage might introduce TCO increase, negating the benefits of memory expansion through a slow memory tier.
</span><span>
</span></code></pre>
<table><thead><tr><th></th><th>Total</th><th><code>invept</code></th><th>Elapsed</th><th>Seconds</th></tr></thead><tbody>
<tr><td>H-TPP</td><td>82,504,466</td><td>20,214,840</td><td>14:56.35</td><td>896.35</td></tr>
<tr><td>G-TPP</td><td>17,707,154</td><td>0</td><td>5:53.91</td><td>353.91</td></tr>
<tr><td>G-Ours</td><td>9,305,363</td><td>0</td><td>4:59.57</td><td>299.57</td></tr>
</tbody></table>
<h2 id="design">Design</h2>
<ul>
<li>
<p>Design Concept: Delegating TMM to Guest OS</p>
<ol>
<li>Can avoid excessive TLB flush</li>
<li>Able to utilize gVA locality
<ul>
<li>gVA locality 只存在于 guest 现有用 PA 空间存在 fragmentation 问题</li>
</ul>
</li>
<li>Able to utilize PEBS</li>
</ol>
<ul>
<li>Implementation Choice: Follow application-transparent (e.g., HeteroOS), but can also support application-tailored (e.g., HeMem)</li>
</ul>
</li>
<li>
<p>Efficient and Scalable TMM</p>
<ul>
<li><del>Ref fig2: PEBS still waste 0.5 cores</del></li>
<li>cost per sample?</li>
<li>Efficient page migration</li>
</ul>
</li>
<li>
<p>Elastic TMP</p>
<ul>
<li>SOTA: hotplugging / ballooning</li>
<li>Fine granularity</li>
<li>TM awareness</li>
<li>Host controlreduce locking and TLB flush (intermediate page)</li>
</ul>
</li>
</ul>
<h2 id="implementation">Implementation</h2>
<h2 id="evaluation">Evaluation</h2>
<h2 id="related-works">Related Works</h2>
<ul>
<li>
<p>PML-based access tracking</p>
<ul>
<li>No address filtering support</li>
</ul>
</li>
<li>
<p>PEBS buf</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Guest support has existed since early versions of PEBS @intel-sdm.
</span><span>However, little attention was paid to it due to an old bug not fixed until version 5 @lkml22eptfriendlypebs.
</span><span>Guest memory pages are usually lazily allocated upon #a[EPT] page faults, allowing the hypervisor to overcommit memory beyond the total physical capacity.
</span><span>In early PEBS implementations, the sample write process could not be interrupted by #a[EPT] page faults @lkml14silvermontpebs.
</span><span>When the PEBS buffer’s memory was lazily allocated or swapped to disk, and a PEBS sample was generated, the system would crash, causing catastrophic failures that could bring down all virtual machines running on the same physical server.
</span><span>Although Intel mentioned a workaround @intel-sdm, it required fully populating all memory pages before launching a VM and completely disabling swapping @lkml14silvermontpebs, which was not economically feasible for cloud vendors.
</span><span>
</span><span>With the introduction of EPT-friendly #a[PEBS] in version 5 @lkml22eptfriendlypebs, #a[PEBS] sample writes can continue after being interrupted by an #a[EPT] page fault.
</span><span>Hypervisors no longer need to pre-allocate all memory pages or disable swapping, making #a[PEBS] a free bonus feature to enable in the cloud.
</span><span>This advancement allows guest operating systems to leverage instruction sampling efficiently and securely, facilitating low-overhead hotness tracking necessary for effective tiered memory management in virtualized environments.
</span></code></pre>
</li>
</ul>
<h2 id="discussion">Discussion</h2>
<ul>
<li>HeMem</li>
</ul>
<hr />
<h4 id="raw-data">Raw data</h4>
<table><thead><tr><th></th><th></th><th>Host</th><th>Guest</th><th>Ours</th></tr></thead><tbody>
<tr><td>Root</td><td><code>tlb_flush </code></td><td>58697567</td><td>1330</td><td>1029</td></tr>
<tr><td>Root</td><td><code>remote_tlb_flush</code></td><td>20214840</td><td>0</td><td>0</td></tr>
<tr><td>Non-root</td><td><code>nr_tlb_local_flush_one</code></td><td>2976774</td><td>2752613</td><td>2753576</td></tr>
<tr><td>Non-root</td><td><code>nr_tlb_remote_flush</code></td><td>602668</td><td>14929754</td><td>6508334</td></tr>
<tr><td>Non-root</td><td><code>nr_tlb_local_flush_all</code></td><td>12617</td><td>23457</td><td>42424</td></tr>
<tr><td></td><td>Total flush</td><td>82,504,466</td><td>17,707,154</td><td>9,305,363</td></tr>
<tr><td></td><td>GUPS Elapsed</td><td>14:56.35</td><td>5:53.91</td><td>4:59.57</td></tr>
</tbody></table>


    </main>

    <footer>
      
  <p class="taxonomies">
    
  </p>


      
    </footer>
  </div>
</body>

</html>
