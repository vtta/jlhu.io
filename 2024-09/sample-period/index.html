<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible" />
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />

  
    
  

  
    
  

  
    
  

  

  
    
  

  <title>Junliang Hu 胡俊良</title>

  
    <meta name="title" content="Junliang Hu 胡俊良">
    <meta name="author" content="Junliang Hu">
    <meta name="description" content="Junliang Hu&#x27;s homepage">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jlhu.io/2024-09/sample-period/">
    <meta property="og:site_name" content="Junliang Hu 胡俊良">
    <meta property="og:title" content="Junliang Hu 胡俊良">
    <meta property="og:description" content="Junliang Hu&#x27;s homepage">
    

    
    
      <meta property="twitter:card" content="summary_large_image">
      <meta property="twitter:url" content="https://jlhu.io/2024-09/sample-period/">
      <meta property="twitter:title" content="Junliang Hu 胡俊良">
      <meta property="twitter:description" content="Junliang Hu&#x27;s homepage">
      
    

    <link rel="canonical" href="https://jlhu.io/2024-09/sample-period/">
    
    <script type="application/ld+json">
      {
          "description": "Junliang Hu's homepage",
          "url": "https://jlhu.io/2024-09/sample-period/",
          "@type": "WebSite",
          "headline": "Junliang Hu 胡俊良",
          "name": "Junliang Hu 胡俊良",
          "author": { "@type": "Person", "name": "Junliang Hu" },
          "@context":"https://schema.org"
      }
    </script>
  

  

   
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            // • rendering keys, e.g.:
            throwOnError : false
          });
      });
  </script>
  

  
    <link rel="stylesheet" href="https://jlhu.io/style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons@latest/iconfont/tabler-icons.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  
</head>

<body theme="auto">
  <div class="w">
    <header>
      
        <nav>
          
            <a href="/" >~jlhu</a>
          
            <a href="/tags" >#tags</a>
          
        </nav>
      

      
  <p>
    <a href="..">..</a>/sample-period
  </p>
  <p class="post-meta">
    <time datetime=""></time>
  </p>
  <h1></h1>

    </header>

    <main class="page-content" aria-label="Content">
      
  

  <p>尽管之前偶然测得我的设计能到90%的DRAM ratio. 但是后来无法复现, 且波动巨大. 怀疑是PEBS引入的不稳定性, 所以想看看到底PEBS到底怎样才能带来最好的结果.</p>
<p>之前实验发现使用load+store事件并不能有效的发现cold folio, DRAM heap也非常小. 后来改为保留一个全局事件, 并使用一个独立事件抓取尽量多的DRAM访存信息, 希望这样可以尽可能多的发现DRAM cold folio.</p>
<p>这里改变了两个事件的sample period来看看这个设计有效与否. 同时每个setting同时运行5个VM, 防止出现偶然事件.</p>
<p><a href="https://web.pc49058.tunnel.jlhu.io/data/projects/workspace/archive/2024-09-10T23:44:28.608346+08:00-sample_frequency-all/report-period.html">https://web.pc49058.tunnel.jlhu.io/data/projects/workspace/archive/2024-09-10T23:44:28.608346+08:00-sample_frequency-all/report-period.html</a></p>
<p>从目前的结果看来基本上还是没法发现cold folio. Hotset DRAM ratio最高也才不到三分之一, 即便DRAM heap中已经有了全部的DRAM folio (≈250k).</p>
<p>考虑将DRAM的hotset识别改为排除式, 即维护一个所有DRAM的set. 从PEBS sample中观测到的folio全部列为hot. 其余全部尝试做demotion. 直到PMEM heap中不在有candidate.</p>
<p>这里的假设是: 在sample frequency较低时, 采样到的地址大概率就是hot的. 先用perf record做个实验, 记录不同frequency下采样地址属于hot set的概率.</p>
<p>需要的改动: <del>gups需要输出hotset的区间地址.</del> 已经实现了, 输出格式: <code>memory 0x7fc548c000d0 length 13950255104</code></p>
<p><a href="https://web.pc49058.tunnel.jlhu.io/data/projects/workspace/archive/2024-09-11T11:04:15.586819+08:00-event_selection/0/gups/event-selection.html">https://web.pc49058.tunnel.jlhu.io/data/projects/workspace/archive/2024-09-11T11:04:15.586819+08:00-event_selection/0/gups/event-selection.html</a></p>
<p>从目前看sample frequency和P(hotset)关系不大, 反而事件的选取更能影响P(hotset). 并且确实sample中存在hot的bias, 比如选取L3Miss事件时约87%的sample都是在访存hotset.</p>
<p>所以现在只要保重余下的访存能够touch到足够多的DRAM区域, 以提供demotion的candidate. 这样我们就可以单纯只靠这一个event来即识别hotset有找到demotion candidate.</p>
<p>那这个事件到底该是l3miss还是loadlat? 从图中看他俩最终P(hotset)差距不大, 但是sample的量却差了好几个数量级, 我们当然是希望用更少的sample来识别出hotset, 即开销更低.</p>
<p>所以接下来做一个实验, 把之前的store event换成ldlat, 然后local load event先不动, 理想情况下在这个额外事件sample frequency很低的时候仍然能达到较高的hotset ratio就说明之用一个ldlat事件是可行的.</p>
<p><a href="https://web.pc49058.tunnel.jlhu.io/data/projects/workspace/archive/2024-09-11T22:30:56.439396+08:00-sample_frequency-ldlat-all/report-period.html">https://web.pc49058.tunnel.jlhu.io/data/projects/workspace/archive/2024-09-11T22:30:56.439396+08:00-sample_frequency-ldlat-all/report-period.html</a></p>
<p>实验效果很差, 不管ldlat和dram event怎么变化, hotset ratio都低于1%. 理论上87%sample属于hotset, 那么仅看页地址的sample计数怎么说也能发现大部份hotset. 目前怀疑是decaying引起的. 尝试关闭decay, 回退到最原始的sketch只看总计数.</p>


    </main>

    <footer>
      
  <p class="taxonomies">
    
  </p>


      
    </footer>
  </div>
</body>

</html>
